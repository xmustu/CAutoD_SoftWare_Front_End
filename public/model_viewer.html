<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>3D 模型查看器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">3D 模型查看器</h1>
        
        <div class="bg-white rounded-lg shadow-lg p-6 max-w-4xl mx-auto">
            <div id="model-container" class="w-full h-[600px] border border-gray-200 rounded-lg overflow-hidden"></div>
            
            <div id="controls-container" class="mt-6 flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-4">
                <input 
                    type="text" 
                    id="model-url-input" 
                    placeholder="输入模型URL (例如: /model)" 
                    class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    value="/model"
                />
                <button id="load-model-button" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition duration-300 flex items-center">
                    <i class="fa fa-upload mr-2"></i> 加载模型
                </button>
            </div>
            <div id="loading-indicator" class="mt-4 text-center text-gray-600 hidden">
                <i class="fa fa-spinner fa-spin mr-2"></i> 正在加载模型...
            </div>
            <div id="error-message" class="mt-4 text-center text-red-500 hidden">
                加载模型失败，请检查URL或稍后重试。
            </div>
        </div>
    </div>
    
    <script>
        const container = document.getElementById('model-container');
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorMessage = document.getElementById('error-message');
        const modelUrlInput = document.getElementById('model-url-input');
        const loadModelButton = document.getElementById('load-model-button');
        const controlsContainer = document.getElementById('controls-container');

        // 初始化Three.js场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        // 相机
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.z = 20;
        
        // 渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);
        
        // 控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // 加载STL模型
        async function loadModel(fullModelUrl) {
            loadingIndicator.classList.remove('hidden');
            errorMessage.classList.add('hidden');

            try {
                const token = localStorage.getItem("token"); // 从 localStorage 获取 token
                const headers = {
                    'Content-Type': 'application/json' // POST 请求需要设置 Content-Type
                };
                if (token) {
                    headers['Authorization'] = `Bearer ${token}`;
                }

                // 从 fullModelUrl 中解析出参数，并提供 window.location.origin 作为 base URL
                const urlObj = new URL(fullModelUrl, window.location.origin);
                const params = new URLSearchParams(urlObj.search);
                const taskId = params.get('task_id');
                const conversationId = params.get('conversation_id');
                const fileName = params.get('file_name');

                const requestBody = {
                    task_id: parseInt(taskId), // 确保是整数
                    conversation_id: conversationId,
                    file_name: fileName
                };

                // 移除 URL 中的查询参数，只保留基础路径
                // 这里直接使用 urlObj.pathname，因为 Nginx 会根据配置代理 /model 到后端
                const baseUrl = urlObj.pathname;

                const response = await fetch(baseUrl, {
                    method: 'POST', // 使用 POST 方法
                    headers: headers,
                    body: JSON.stringify(requestBody) // 发送 JSON 请求体
                });
                console.log("Fetch response headers:", response.headers); // 打印响应头
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const contentType = response.headers.get('Content-Type');
                if (contentType && contentType.includes('text/html')) {
                    const htmlContent = await response.text();
                    console.error("Received HTML instead of STL:", htmlContent);
                    throw new Error("后端返回了HTML页面，而不是STL模型文件。请检查后端服务。");
                }

                const arrayBuffer = await response.arrayBuffer(); // 获取 ArrayBuffer
                console.log("ArrayBuffer byteLength:", arrayBuffer.byteLength); // 打印 ArrayBuffer 长度
                // 打印 ArrayBuffer 的前几个字节，转换为可读字符串
                const uint8Array = new Uint8Array(arrayBuffer);
                console.log("ArrayBuffer first 20 bytes:", Array.from(uint8Array.slice(0, 20)).map(b => b.toString(16).padStart(2, '0')).join(' '));

                const loader = new THREE.STLLoader();
                const geometry = loader.parse(arrayBuffer); // 解析 ArrayBuffer

                // 清除现有模型
                const objectsToRemove = scene.children.filter(
                    (child) => child instanceof THREE.Mesh
                );
                objectsToRemove.forEach((child) => scene.remove(child));
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x0070f3, 
                    shininess: 100,
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                // 计算模型中心并居中
                geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                geometry.boundingBox.getCenter(center);
                mesh.position.sub(center);
                
                // 适当缩放
                const size = new THREE.Vector3();
                geometry.boundingBox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                console.log("Model original max dimension:", maxDim); // 打印原始最大维度
                const scale = 300 / maxDim; // 缩放模型，使其最大维度为 300，以显示更大
                console.log("Calculated scale:", scale); // 打印缩放比例
                mesh.scale.set(scale, scale, scale);
                
                scene.add(mesh);
                
                // 调整相机位置，使其更靠近模型
                // 根据模型缩放后的尺寸调整相机位置
                const scaledSize = size.clone().multiplyScalar(scale);
                const maxScaledDim = Math.max(scaledSize.x, scaledSize.y, scaledSize.z);
                console.log("Model scaled max dimension:", maxScaledDim); // 打印缩放后最大维度
                camera.position.z = maxScaledDim * 1.5; // 调整相机Z轴位置，拉远一些以容纳更大的模型
                camera.lookAt(scene.position); // 让相机看向场景中心
                controls.update(); // 更新控制器以反映相机位置变化

                loadingIndicator.classList.add('hidden');
            } catch (error) {
                console.error('An error happened', error);
                loadingIndicator.classList.add('hidden');
                errorMessage.classList.remove('hidden');
            }
        }
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // 解析URL查询参数
        const urlParams = new URLSearchParams(window.location.search);
        const initialModelUrl = urlParams.get('modelUrl');
        const backendApiBaseUrl = urlParams.get('backendApiBaseUrl');

        console.log("Initial Model URL from params:", initialModelUrl);
        console.log("Backend API Base URL from params:", backendApiBaseUrl);

        if (initialModelUrl && backendApiBaseUrl) {
            const fullModelUrl = `${decodeURIComponent(backendApiBaseUrl)}${decodeURIComponent(initialModelUrl)}`;
            console.log("Full Model URL to load:", fullModelUrl);
            loadModel(fullModelUrl);
            // 隐藏输入框和按钮
            controlsContainer.classList.add('hidden');
        } else {
            console.log("No initial model URL or backend API base URL found in params. Showing manual input.");
            // 加载模型按钮事件
            loadModelButton.addEventListener('click', () => {
                const url = modelUrlInput.value;
                if (url) {
                    loadModel(url);
                } else {
                    alert('请输入模型URL！');
                }
            });
            
            // 初始加载模型（如果URL输入框有默认值）
            if (modelUrlInput.value) {
                loadModel(modelUrlInput.value);
            }
        }
        animate();
    </script>
</body>
</html>
